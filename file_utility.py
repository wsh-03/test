import os
import csv
import shutil
import re
import os 

class FileProcessor:
    DRIVER_NAME_KEY = "Driver_Name"
    LOC_KEY = "Line_of_Code"
    PATH_KEY = "Path"
    FILE_KEY = "File_Name"
    home_dir = os.environ.get("HOME")
    helper_file_path = f"{home_dir}/linux/rust/bindings/bindings_helper.h"
    
    # Retrieve the file content
    def get_file_info(self, path2file, file_type):
        if not os.path.isfile(path2file):
            print(f"Error: {path2file} is not a valid file path.")
            return None, None
        try:
            os.path.splitext(path2file)[1] == file_type
            file_name = os.path.basename(path2file)
            with open(path2file, 'r') as f:
                file_content = f.read()
                return file_content, file_name
        except Exception as e:
            print(f"Error: {e}")
            return None, None
        
        return None, None
    
    # List the full path of a file in the target directory
    def list_files(self, path2folder, file_type):
        if not os.path.isdir(path2folder):
            return None
        file_path = []
        for root, _, files in os.walk(path2folder):
            for file_name in files:
                # Check if the file name match the specific type
                if os.path.splitext(file_name)[1] == file_type:
                    # Get the path to the file
                    path2file = os.path.join(root, file_name)
                    file_path.append(path2file)
        return file_path
        
    # Remove comments from a file
    def remove_comments(self, file):
        # Check if `file` is a valid file path or raw content
        if os.path.isfile(file):
            with open(file, 'r') as f:
                lines = f.read()
        elif file != "":
            lines = file  # Assume it's raw file content as a string
        else:
            return None
        
        code = lines
    
        # Patterns for /* */ muilti line style comment
        pattern4m = re.compile(r'/\*.*?\*/', flags=re.DOTALL)
        # Pattern for ``` style single line comment
        pattern4llm = re.compile(r'```.*')
        # Patther for // style single line comment
        patthern4s = re.compile(r'//.*')
    
        # Remove all /* */ style comments (multi-line): C style comment
        code = re.sub(pattern4m, "", code)
        # Remove all // style comments (single-line): C style comment
        code = re.sub(patthern4s, "", code)
        # Remove ``` style comment (single-line) result generated by LLM
        code = re.sub(pattern4llm,"",code)
    
        return code
    
    def get_base_name(self, log_message):
        # Define the regex pattern to match the RUSTC line
        pattern = r"RUSTC\s+(.*\.o)"
        match = re.search(pattern, log_message)
        if match:
            # Extract the full file path
            file_path = match.group(1)
            # Get the base name of the file without extension
            file_name = file_path.split("/")[-1].replace(".o", "")
            return file_name
        else:
            return None
        
    def write_lod(self, list_of_dic, output_file):
        if not list_of_dic:
            print("write_lod_Error: The list of dictionaries is empty, cannot log into the csv file.")
            return False
        # Sort the lines of code of each file in ascending order
        sorted_lod= sorted(list_of_dic, key=lambda x: x[f'{self.LOC_KEY}'])
        # Get the fieldnames of the dictionary
        field_names = sorted_lod[0].keys()
        # Log information into a CSV file
        with open(f"{output_file}", 'w', newline='') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames = field_names )
            writer.writeheader()
            writer.writerows(sorted_lod)
        return True
    
    # log the information of all driver files in the Linux directory
    def log_file(self, path2driver, file_type, output_file):
        
        if not os.path.isdir(path2driver):
            print(f"log_file_ERROR: {path2driver} not found")
            return False
        
        # Find the lines of code and remove the comments from each file in the target directory
        file_info = []
        for root, dirs, files in os.walk(path2driver):
            for file in files:
                # Extract specified file type
                if os.path.splitext(file)[1] == file_type:
                    # Get the path to the file
                    path2file = os.path.join(root, file)
                    # print(f"Path to file: {path2file}")
                    
                    # Remove comments in the file
                    if file_type != ".o":
                        processed_file = self.remove_comments(path2file)
                        # print("clean code: \n", processedFile)
                        split_by_line = processed_file.split("\n")  # Split the code into lines
                        line_of_code = len(split_by_line)
                    else:
                        line_of_code = 0
                    
                    # Extract the driver name based on the path
                    relative_path = os.path.relpath(path2file, path2driver)
                    split_path = relative_path.split(os.sep)
                    if len(split_path) > 1:
                        driver_name = split_path[0]
                    
                    # print(f"Driver Name: {driver_name}")
                    # print(f"Path to File: {path2file}")
                    # print(f"Lines of Code: {line_of_code}")
                    
                    
                    # Append the file information to the list of Dictionaries
                    file_info.append({f'{self.DRIVER_NAME_KEY}': driver_name, 
                                        f'{self.PATH_KEY}': path2file, 
                                        f'{self.FILE_KEY}': file, 
                                        f'{self.LOC_KEY}': line_of_code
                                        })
            
        result = self.write_lod(file_info, output_file)
        if not result:
            return False
        return True
    
    

    # Summary the lines of code of each file in a driver and log the information into a CSV file
    def count_driver_loc(self, path2csv, output_file):
        if not os.path.isfile(path2csv):
            return None
        # Store LOC in a single dictionary
        file_info = {}
        try:
            # Read CSV file
            with open(path2csv, 'r') as info:
                csvreader = csv.DictReader(info)
                for row in csvreader:
                    loc = int(row[self.LOC_KEY])
                    driver_name = row[self.DRIVER_NAME_KEY]
                    file_info[driver_name] = file_info.get(driver_name, 0) + loc
                    print(f"Driver Name: {driver_name}, Path: {row[self.PATH_KEY]}, Total LOC: {loc}")

            # Print LOC
            # for driver, loc in file_info.items():
            #     print(f"Driver Name: {driver}, Total LOC: {loc}")
            
            # Write summary to a CSV file
            field_names = [self.DRIVER_NAME_KEY, self.LOC_KEY]                
            data = [{f"{self.DRIVER_NAME_KEY}": driver, f"{self.LOC_KEY}": loc} for driver, loc in file_info.items()]
            sorted_data = sorted(data, key=lambda x: x[self.LOC_KEY])
            with open(f"{output_file}", 'w', newline='') as summary_file:
                writer = csv.DictWriter(summary_file, fieldnames=field_names)
                writer.writeheader()
                writer.writerows(sorted_data)

        except Exception as e:
            print(f"count_driver_loc_Error: {e}")

    # Get the headers from a C file
    def get_headers(self, file):
        # Check if file is a valid string file path or header file data
        if isinstance(file, str):
            if os.path.isfile(file): 
                with open(file, 'r') as f:
                    lines = f.read()
            else: 
                # Assume it's raw file content as a string
                lines = file
        else:
            return None
        # Pattern for C header
        pattern4h = re.compile(r'#include.*')
        # Find all headers
        headers = re.findall(pattern4h, lines)
        return headers
    
    # Update the header helper file with the unique headers from the C files
    def update_header_helper(self, file_path):
        if not os.path.isfile(file_path):
            return None
        
        # Compare the headers in the binding helper file with the headers in the C files
        unique_headers = []
        for header in self.get_headers(file_path):
            if header not in self.get_headers(self.helper_file_path):
                unique_headers.append(header)
        # Write the unique headers to the header helper file
        with open(self.helper_file_path, 'r') as f:
            helper_content = f.readlines()
        for header in unique_headers:
            for line in range(1, len(helper_content)):
                if helper_content[line] == "\n":
                    helper_content.insert(line, header)
                    break
        with open(self.helper_file_path, 'w') as f:
            f.writelines(helper_content)            
        
    
    # Get the target driver header files and copy them to the new directory according to the file location in the csv file
    def get_driver_header(self, path2csv, path2folder, driver_name):
        if not os.path.isdir(path2folder):
            print(f"ERROR: {path2folder} not found")
            return False
        
        headers = []
        header_output = f"{self.home_dir}/test/{driver_name}/{driver_name}_headers.h"
        output_csv = "driver_loc_summary.csv"
        if not os.path.isfile(path2csv):
            self.log_file(path2folder, ".c", "summary.csv")
            self.count_driver_loc(path2csv, output_csv)
        with open(path2csv, 'r') as info:
            file_info = csv.DictReader(info)
            for row in file_info:
                if row[self.DRIVER_NAME_KEY] == f'{driver_name}' and int(row[self.LOC_KEY]) <= 200:
                    output_dir = os.path.join(os.path.dirname(path2csv), driver_name, f"d_{row[self.FILE_KEY]}")
                    # Create the directory and Copy the file to the new directory according to the file location in csv
                    os.makedirs(output_dir, exist_ok=True)
                    print("Path Created: ", output_dir)
                    shutil.copy(row[f'{self.PATH_KEY}'], output_dir)
                    # Collect only unique headers in the C files
                    for header in self.get_headers(row[f'{self.PATH_KEY}']):
                        if header not in headers:
                            headers.append(header)
        print("Headers: ", headers)
        # Write all unique headers to a C file in the directory
        with open(header_output, 'w') as f:
            for header in headers:
                f.write(header + "\n")
        # Update the header helper file
        self.update_header_helper(header_output)
        return True
        

if __name__ == '__main__':
    file = FileProcessor()


    # path2csv = "/home/wsh/test/driver_summary.csv"
    path2folder = "/home/wsh/linux/drivers"
    # driver_name = "rtc"
    # file.get_driver_header(path2csv, path2folder, driver_name)
    
    file.log_file(path2folder, ".o", "summary_o.csv")